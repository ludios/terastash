{
  "name": "chopshop",
  "version": "0.3.0",
  "description": "Chunks an io.js readable stream into multiple fixed-length streams",
  "homepage": "https://github.com/ludios/chopshop",
  "issues": "https://github.com/ludios/chopshop/issues",
  "keywords": [
    "stream",
    "streams",
    "chunk",
    "chunker",
    "chunking"
  ],
  "main": "index.js",
  "scripts": {
    "test": "mocha tests/*.js && ./node_modules/.bin/eslint .",
    "test-strong-mode": "iojs --strong_mode ./node_modules/.bin/_mocha tests/*.js"
  },
  "devDependencies": {
    "co": "^4.6.0",
    "eslint": "^0.24.1",
    "mocha": "^2.2.5"
  },
  "author": {
    "name": "Ivan Kozik"
  },
  "license": "ISC",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ludios/chopshop.git"
  },
  "engines": {
    "iojs": ">= 2.0.0"
  },
  "readme": "chopshop\n===\n\n[![NPM version][npm-image]][npm-url]\n[![Build status][travis-image]][travis-url]\n\nchopshop takes an io.js readable [stream](https://iojs.org/api/stream.html)\nand yields a series of fixed-length streams.  This is particularly useful\nif you need to convert a file into multiple files of size N.\n\n\nInstall\n---\n\nIn your project, run:\n\n```\nnpm install chopshop --save\n```\n\nor install from the GitHub repo:\n\n```\nnpm install ludios/chopshop --save\n```\n\n\nAPI\n---\n```js\nconst chunk = require('chopshop').chunk;\nchunk(readableStream, maxBytes);\n```\n\n`chunk` returns an iterable of readable streams, all `maxBytes` in size\nexcept for the last chunk, which may be smaller.  You must finish reading\na chunk before you start reading the next chunk.  If your input stream\nhas 0 bytes, you still get one chunk with 0 bytes.\n\n\nExample\n---\n\n```js\n\"use strict\";\n\nconst chunk = require('chopshop').chunk;\nconst fs = require('fs');\nconst co = require('co');\n\nco(function*() {\n\tfor(const chunkStream of chunk(fs.createReadStream('/etc/passwd'), 100)) {\n\t\tchunkStream.on('data', function(data) {\n\t\t\tprocess.stdout.write(data);\n\t\t\tconsole.log(\"\\n\" + data.length + \"\\n\");\n\t\t});\n\t\tyield new Promise(function(resolve) {\n\t\t\tchunkStream.on('end', resolve);\n\t\t});\n\t}\n}).catch(function(e) {\n\tconsole.error(e.stack);\n});\n```\n\nBe careful: you must not start reading from the next chunk before you finish\nreading from the current chunk.  That's why we use `co` and a `Promise` above\nto wait for the chunk to finish.\n\n[npm-image]: https://img.shields.io/npm/v/chopshop.svg\n[npm-url]: https://npmjs.org/package/chopshop\n[travis-image]: https://img.shields.io/travis/ludios/chopshop.svg\n[travis-url]: https://travis-ci.org/ludios/chopshop\n",
  "readmeFilename": "README.md",
  "gitHead": "ba723a9c735f1c84546d54b666d1bfa5ef726494",
  "bugs": {
    "url": "https://github.com/ludios/chopshop/issues"
  },
  "_id": "chopshop@0.3.0",
  "_shasum": "dd206a2352c53acc0ae3d8494e3ff388e005e76e",
  "_from": "chopshop@>=0.3.0 <0.4.0"
}
